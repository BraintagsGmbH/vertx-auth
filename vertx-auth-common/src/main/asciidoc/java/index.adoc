= Vert.x Auth - Authentication and Authorisation

This Vert.x component provides interfaces for authentication and authorisation that can be used from your Vert.x
applications and can be backed by different providers.

It also provides an implementation that uses http://shiro.apache.org/[Apache Shiro] out-of-the-box but you can provide
your own implementation by implementing the `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]` interface.

The Vert.x Apache Shiro implementation
currently allows user/permission information to be accessed from simple properties files or LDAP servers.

Vert.x auth is also used by vertx-web to handle its authentication and authorisation.

== Basic concepts

_Authentication_ (aka _log in_) means verifying the identity of a user.

_Authorisation_ means verifying a user is allowed to access some resource.

The service uses a familiar user/permission model that you will probably know already:

Permission is a statement that describes raw functionality in the application and nothing more. Permissions are
described as a _opaque_ `link:../../apidocs/java/lang/String.html[String]`, meaning that vert.x makes no assumption on the format of the
String.

A Permission can be e.g.: "code:push", "code_push", "printers:print:lab1-printer". A common pattern to define these
Strings is "domain[:action[:instance]], however the choice is up to the developer.

== Authentication

To authenticate a user you use `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html#authenticate-io.vertx.core.json.JsonObject-io.vertx.core.Handler-[authenticate]`.

The first argument is a JSON object which contains authentication information. What this actually contains depends
on the specific implementation; for a simple username/password based authentication it might contain something like:

----
{
  "username": "tim"
  "password": "mypassword"
}
----

For an implementation based on JWT token or OAuth bearer tokens it might contain the token information.

Authentication occurs asynchronously and the result is passed to the user on the result handler that was provided in
the call. The async result contains an instance of `link:../../apidocs/io/vertx/ext/auth/User.html[User]` which represents the authenticated
user and contains operations which allow the user to be authorised.

Here's an example of authenticating a user using a simple username/password implementation:

[source,java]
----
JsonObject authInfo = new JsonObject().put("username", "tim").put("password", "mypassword");

authProvider.authenticate(authInfo, res -> {
  if (res.succeeded()) {

    User user = res.result();

    System.out.println("User " + user.principal() + " is now authenticated");

  } else {
    res.cause().printStackTrace();
  }
});
----

== Authorisation

Once you have an `link:../../apidocs/io/vertx/ext/auth/User.html[User]` instance you can call methods on it to authorise it.

to check if a user has a specific permission you use `link:../../apidocs/io/vertx/ext/auth/User.html#isPermitted-java.lang.String-io.vertx.core.Handler-[isPermitted]`,
to check if a user has all the specified permissions you use `link:../../apidocs/io/vertx/ext/auth/User.html#isPermitted-java.lang.String-io.vertx.core.Handler-[isPermitted]`.

The results of all the above are provided asynchronously in the handler.

Here's an example of authorising a user:

[source,java]
----
user.isPermitted("admin", res -> {
  if (res.succeeded()) {

    boolean hasPermission = res.result();

    if (hasPermission) {
      System.out.println("User has the permision");
    } else {
      System.out.println("User does not have the permision");
    }

  } else {
    res.cause().printStackTrace();
  }
});
----

Matching of Permissions is expected to be done using String equality unless otherwise stated by the underlying
implementation.

=== Caching permissions

The user object will cache any permissions so subsequently calls to check if it has the same permissions will result
in the underlying provider being called.

In order to clear the internal cache you can use `link:../../apidocs/io/vertx/ext/auth/User.html#clearCache--[clearCache]`.

=== The User Principal

You can get the Principal corresponding to the authenticated user with `link:../../apidocs/io/vertx/ext/auth/User.html#principal--[principal]`.

What this returns depends on the underlying implementation.

== Creating your own auth implementation

If you wish to create your own auth provider you should implement the `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]` interface.

We provide an abstract implementation of user called `link:../../apidocs/io/vertx/ext/auth/AbstractUser.html[AbstractUser]` which you can subclass
to make your user implementation. This contains the caching logic so you don't have to implement that yourself.

If you wish your user objects to be clusterable you should make sure they implement `link:../../apidocs/io/vertx/core/shareddata/impl/ClusterSerializable.html[ClusterSerializable]`.