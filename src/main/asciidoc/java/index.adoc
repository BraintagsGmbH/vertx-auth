= Vert.x Auth - Authentication and Authorisation

This Vert.x component provides interfaces for authentication and authorisation that can be used from your Vert.x
applications and can be backed by different providers.

It also provides an implementation that uses http://shiro.apache.org/[Apache Shiro] out-of-the-box but you can provide
your own implementation by implementing the `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]` interface.

The Vert.x Apache Shiro implementation
currently allows user/role/permission information to be accessed from simple properties files or LDAP servers.

Vert.x auth is also used by vertx-web to handle its authentication and authorisation.

== Basic concepts

_Authentication_ (aka _log in_) means verifying the identity of a user.

_Authorisation_ means verifying a user is allowed to access some resource.

The service uses a familiar user/role/permission model that you will probably know already:

Users can have zero or more roles, e.g. "manager", "developer".

Roles can have zero or more permissions, e.g. a manager might have permission "approve expenses", "conduct_reviews",
and a developer might have a permission "commit_code".

== Authentication

To authenticate a user you use `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html#authenticate-io.vertx.core.json.JsonObject-io.vertx.core.Handler-[authenticate]`.

The first argument is a JSON object which contains authentication information. What this actually contains depends
on the specific implementation; for a simple username/password based authentication it might contain something like:

----
{
  "username": "tim"
  "password": "mypassword"
}
----

For an implementation based on JWT token or OAuth bearer tokens it might contain the token information.

Authentication occurs asynchronously and the result is passed to the user on the result handler that was provided in
the call. The async result contains an instance of `link:../../apidocs/io/vertx/ext/auth/User.html[User]` which represents the authenticated
user and contains operations which allow the user to be authorised.

Here's an example of authenticating a user using a simple username/password implementation:

[source,java]
----
JsonObject authInfo = new JsonObject().put("username", "tim").put("password", "mypassword");

authProvider.authenticate(authInfo, res -> {
  if (res.succeeded()) {

    User user = res.result();

    System.out.println("User " + user.principal() + " is now authenticated");

  } else {
    res.cause().printStackTrace();
  }
});
----

=== Re-creating users from Buffers

The operation `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html#fromBuffer-io.vertx.core.buffer.Buffer-[fromBuffer]` allows a User object
to be reconstructed from a `link:../../apidocs/io/vertx/core/buffer/Buffer.html[Buffer]`. This is primarily used in vertx-web session clustering
to allow the instance to be serialized in the session and passed over the wire to other nodes of the cluster.

== Authorisation

Once you have an `link:../../apidocs/io/vertx/ext/auth/User.html[User]` instance you can call methods on it to authorise it.

To check if a user has a specific role you use `link:../../apidocs/io/vertx/ext/auth/User.html#hasRole-java.lang.String-io.vertx.core.Handler-[hasRole]`,
to check if a user has all the specified roles you use `link:../../apidocs/io/vertx/ext/auth/User.html#hasRoles-java.util.Set-io.vertx.core.Handler-[hasRoles]`,
to check if a user has a specific permission you use `link:../../apidocs/io/vertx/ext/auth/User.html#hasPermission-java.lang.String-io.vertx.core.Handler-[hasPermission]`,
to check if a user has all the specified permissions you use `link:../../apidocs/io/vertx/ext/auth/User.html#hasPermissions-java.util.Set-io.vertx.core.Handler-[hasPermissions]`.

The results of all the above are provided asynchronously in the handler.

Here's an example of authorising a user:

[source,java]
----
user.hasPermission("admin", res -> {
  if (res.succeeded()) {

    boolean hasPermission = res.result();

    if (hasPermission) {
      System.out.println("User has the permision");
    } else {
      System.out.println("User does not have the permision");
    }

  } else {
    res.cause().printStackTrace();
  }
});
----

=== Caching roles and permissions

The user object will cache any roles and permissions so subsequently calls to check if it has the same roles or
permissions will result in the underlying provider being called.

In order to clear the internal cache you can use `link:../../apidocs/io/vertx/ext/auth/User.html#clearCache--[clearCache]`.

=== The User Principal

You can get the Principal corresponding to the authenticated user with `link:../../apidocs/io/vertx/ext/auth/User.html#principal--[principal]`.

What this returns depends on the underlying implementation.

=== Clusterable users

Sometimes users might be put into sessions and clustered to other nodes. For implementations that do not want to
be clustered in this way, they should return `false` from this method.

== The Apache Shiro implementation

This component contains an out of the box implementation that uses http://shiro.apache.org/[Apache Shiro].

We provide out of the box support for properties and LDAP based auth using Shiro.

To create an instance of the provider you use `link:../../apidocs/io/vertx/ext/auth/shiro/ShiroAuth.html[ShiroAuth]`. You specify the type of
Shiro auth provider that you want with `link:../../apidocs/io/vertx/ext/auth/shiro/ShiroAuthRealmType.html[ShiroAuthRealmType]`, and you specify the
configuration in a JSON object.

Here's an example of creating a Shiro auth provider:

[source,java]
----
JsonObject config = new JsonObject().put("properties_path", "classpath:test-auth.properties");

AuthProvider provider = ShiroAuth.create(vertx, ShiroAuthRealmType.PROPERTIES, config);
----

=== The Shiro properties auth provider

This auth provider implementation uses Apache Shiro to get user/role/permission information from a properties file.

The implementation will, by default, look for a file called `vertx-users.properties` on the classpath.

If you want to change this, you can use the `properties_path` configuration element to define how the properties
file is found.

The default value is `classpath:vertx-users.properties`.

If the value is prefixed with `classpath:` then the classpath will be searched for a properties file of that name.

If the value is prefixed with `file:` then it specifies a file on the file system.

If the value is prefixed with `url:` then it specifies a URL from where to load the properties.

The properties file should have the following structure:

Each line should either contain the username, password and roles for a user or the permissions in a role.

For a user line it should be of the form:

 user.{username}={password},{roleName1},{roleName2},...,{roleNameN}

For a role line it should be of the form:

 role.{roleName}={permissionName1},{permissionName2},...,{permissionNameN}

Here's an example:
----
user.tim = mypassword,administrator,developer
user.bob = hispassword,developer
user.joe = anotherpassword,manager
role.administrator=*
role.manager=play_golf,say_buzzwords
role.developer=do_actual_work
----

When describing roles a wildcard `*` can be used to indicate that the role has all permissions

=== The Shiro LDAP auth provider

The LDAP auth realm gets user/role/permission information from an LDAP server.

The following configuration properties are used to configure the LDAP realm:

`ldap-user-dn-template`:: this is used to determine the actual lookup to use when looking up a user with a particular
id. An example is `uid={0},ou=users,dc=foo,dc=com` - the element `{0}` is substituted with the user id to create the
actual lookup. This setting is mandatory.
`ldap_url`:: the url to the LDAP server. The url must start with `ldap://` and a port must be specified.
An example is `ldap:://myldapserver.mycompany.com:10389`
`ldap-authentication-mechanism`:: TODO
`ldap-context-factory-class-name`:: TODO
`ldap-pooling-enabled`:: TODO
`ldap-referral`:: TODO
`ldap-system-username`:: TODO
`ldap-system-password`:: TODO

== Creating your own auth implementation

If you wish to create your own auth provider you should implement the `link:../../apidocs/io/vertx/ext/auth/AuthProvider.html[AuthProvider]` interface.

We provide an abstract implementation of user called `link:../../apidocs/io/vertx/ext/auth/AbstractUser.html[AbstractUser]` which you can subclass
to make your user implementation. This contains the caching logic so you don't have to implement that yourself.

If you wish your user objects to be clusterable you should make sure they implement `link:../../apidocs/io/vertx/core/shareddata/impl/ClusterSerializable.html[ClusterSerializable]`.

=== Using another Shiro Realm

It's also possible to create an auth provider instance using a pre-created Apache Shiro Realm object.

This is done as follows:

[source,java]
----
AuthProvider provider = ShiroAuth.create(vertx, realm);
----

The implementation currently assumes that user/password based authentication is used.